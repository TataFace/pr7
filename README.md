

МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ
Федеральное государственное бюджетное образовательное учреждение высшего образования
"МИРЭА - Российский технологический университет"

РТУ МИРЭА

Институт искусственного интеллекта (ИИ)
Кафедра …





ОТЧЕТ
ПО ПРАКТИЧЕСКОЙ РАБОТЕ №8
по дисциплине

«Вычислительнаые системы реального времени»

Тема: ОРГАНИЗАЦИЯ МЕЖПРОЦЕССНОГО ВЗАИМОДЕЙСТВИЯ. ПРОГРАММНЫЕ КАНАЛЫ 



Выполнил студент группы КВБО-06-23




Соловьева Н.Н
Принял ст. преподаватель кафедры ПИ
Зорина Н.В.




Практические работы выполнены
«16»   ноября  2025г.


«Зачтено»

«    » 	2025 г.








Москва 2025

Постановка задачи

	Цель работы: изучение средств организации межпроцессного взаимодействия, предоставляемых в NIX системах, приобретение навыков программирования программных каналов с использованием API POSIX на языке Си в среде Линукс/Юникс.

Порядок выполнения практической работы
    1. Прочитайте теоретический материал, посвященный использованию указателей для работы с памятью.
    2. Выполните программные примеры, приведенные в практической работе в качестве упражнений.
    3. Напишите реализацию программную конвейеров команд: ls|wc -l, who| wc -l.
    4. Реализуйте свои собственные программные примеры для реализации одностороннего и двустороннего взаимодействия процессов. 
    5. Сделайте скриншоты или скопируйте вывод разработанных вами программ.
    6. Отчет должен содержать полную информацию по разделам о проделанной вами работе и выводы программ, которые вы делаете по результатам работы: опишите результат выполнения программ в вашей ОС.
    7. Оформите отчет по практической работе, загрузите в свой слот СДО МИРЭА и сдайте преподавателю.
    8. Примечание. Отчет должен содержать: титульный лист, название, цель работы и описание выполняемого задания, результат выполнения команд, описание результата выполнения команд.





Выполнение задания

1. Реализация конвейера ls | wc -l

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    int fd[2];
    
    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }
    
    if (fork() == 0) {
        // Дочерний процесс - выполнение ls
        close(fd[0]);  // Закрываем чтение
        dup2(fd[1], STDOUT_FILENO);  // Перенаправляем stdout в канал
        close(fd[1]);
        execlp("ls", "ls", NULL);
        perror("execlp ls");
        exit(1);
    } else {
        // Родительский процесс - выполнение wc -l
        close(fd[1]);  // Закрываем запись
        dup2(fd[0], STDIN_FILENO);  // Перенаправляем stdin из канала
        close(fd[0]);
        execlp("wc", "wc", "-l", NULL);
        perror("execlp wc");
        exit(1);
    }
    
    return 0;
}


Результат выполнения:


2. Реализация конвейера `who | wc -l`

Код программы:
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    int fd[2];
    
    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }
    
    if (fork() == 0) {
        // Дочерний процесс - выполнение who
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        close(fd[1]);
        execlp("who", "who", NULL);
        perror("execlp who");
        exit(1);
    } else {
        // Родительский процесс - выполнение wc -l
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        execlp("wc", "wc", "-l", NULL);
        perror("execlp wc");
        exit(1);
    }
    
    return 0;
}


Результат выполнения:


3. Пример одностороннего взаимодействия

Код программы (односторонний канал):

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int fd[2];
    char message[] = "Hello from parent process!";
    char buffer[128];
    
    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }
    
    if (fork() == 0) {
        // Дочерний процесс - читает из канала
        close(fd[1]);  // Закрываем запись
        read(fd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        close(fd[0]);
    } else {
        // Родительский процесс - пишет в канал
        close(fd[0]);  // Закрываем чтение
        write(fd[1], message, strlen(message) + 1);
        printf("Parent sent: %s\n", message);
        close(fd[1]);
        wait(NULL);  // Ждем завершения дочернего процесса
    }
    
    return 0;
}


Результат выполнения:


4. Пример двустороннего взаимодействия

Код программы (двусторонний канал):

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int fd1[2], fd2[2];
    char parent_msg[] = "Message from parent";
    char child_msg[] = "Message from child";
    char buffer[128];
    
    // Создаем два канала для двусторонней связи
    if (pipe(fd1) == -1 || pipe(fd2) == -1) {
        perror("pipe");
        exit(1);
    }
    
    if (fork() == 0) {
        // Дочерний процесс
        close(fd1[1]);  // Закрываем запись в первый канал
        close(fd2[0]);  // Закрываем чтение из второго канала
        
        // Читаем сообщение от родителя
        read(fd1[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        
        // Отправляем ответ родителю
        write(fd2[1], child_msg, strlen(child_msg) + 1);
        printf("Child sent: %s\n", child_msg);
        
        close(fd1[0]);
        close(fd2[1]);
    } else {
        // Родительский процесс
        close(fd1[0]);  // Закрываем чтение из первого канала
        close(fd2[1]);  // Закрываем запись во второй канал
        
        // Отправляем сообщение ребенку
        write(fd1[1], parent_msg, strlen(parent_msg) + 1);
        printf("Parent sent: %s\n", parent_msg);
        
        // Читаем ответ от ребенка
        read(fd2[0], buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        
        close(fd1[1]);
        close(fd2[0]);
        wait(NULL);
    }
    
    return 0;
}


Результат выполнения:


Анализ результатов

Вывод: Успешно реализованы конвейеры `ls | wc -l` и `who | wc -l`, которые показывают количество файлов в текущей директории и количество активных пользователей соответственно.Реализован простой пример передачи данных от родительского процесса к дочернему через неименованный канал.Создана система с двумя каналами, позволяющая организовать полноценный обмен сообщениями между процессами.
